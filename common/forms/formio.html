<form role="form" id="task-form-formio">
    <!--    TODO make the stylesheets configured from the build so people can change what CSS to load-->
    <link rel="stylesheet" href="/forms/formio.full-4.11.3.min.css">
    <link rel="stylesheet" href="/forms/font-awesome-4.7.0/css/font-awesome.min.css">

    <!-- TODO is it better to have the formio div in the <form> element or outside of it?   -->
    <div id="formio"></div>

    <script cam-script type="text/form-script">
<!--    <script>-->


        let submissionSuffix = '_submission'
        let startFormVariableName = 'startForm' + submissionSuffix;
        let formLocationDeploymentParam = 'deployment'
        let formLocationLocalPathParam = "path"
        let fetchVariableKey = 'fetchVariable';
        let camVariableNameKey = "camVariableName"
        let stringifyKey = "stringify"
        let formioDivId = "formio"
        let submitAsTransientVariableParam = "transient"
        let submitAsTransientVariableDefault = false
        let submissionVariableNameParam = "var"
        let removePrivateValidations = true
        let firstSubmit = true;

        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, '\\$&');
            const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        function cleanPrivateValidations(schema) {
            FormioUtils.eachComponent(schema.components, component => {
                if (component.validate && component.validate.customPrivate) {
                    delete component.validate.custom;
                }
            })
        }

        function getSchema() {
            return new Promise(resolve => {
                inject(['$http', 'Uri', function ($http, Uri) {
                    let processDefId = camForm.processDefinitionId;

                    $http.get(Uri.appUri('engine://engine/:engine/process-definition/' + processDefId)).then(function (response) {

                        let formNameDeployment = getParameterByName(formLocationDeploymentParam, camForm.options.formUrl);
                        let formLocDeployment = function () {
                            return formNameDeployment !== null;
                        }

                        let formNamePath = getParameterByName(formLocationLocalPathParam, camForm.options.formUrl);
                        let formLocPath = function () {
                            return formNamePath !== null;
                        }

                        if (formLocDeployment() === false && formLocPath() === false) {
                            console.error("No valid form json location was found for formio.")
                        }

                        let formName = formLocDeployment() === true ? formNameDeployment : formNamePath
                        let formType = formLocDeployment() === true ? formLocationDeploymentParam : formLocationLocalPathParam

                        return {deploymentId: response.data.deploymentId, formName: formName, formType: formType}

                    }).then(function (details) {

                        if (details.formType === formLocationDeploymentParam) {
                            $http.get(Uri.appUri('engine://engine/:engine/deployment/' + details.deploymentId + '/resources')).then(function (response) {
                                let formResource = response.data.find(i => i.name === details.formName);

                                if (formResource === undefined) {
                                    console.error('Unable to find resource with name: ' + details.formName);
                                }

                                return {deploymentId: details.deploymentId, resourceId: formResource.id}

                            }).then(function (ids) {
                                $http.get(Uri.appUri('engine://engine/:engine/deployment/' + ids.deploymentId + '/resources/' + ids.resourceId + '/data')).then(function (response) {
                                    let schema = response.data
                                    cleanPrivateValidations(schema) // This would be removed in future, but currently there is no server API to clean the files
                                    resolve(schema)
                                });
                            });

                        } else if (details.formType === formLocationLocalPathParam) {
                            let schema = $.getJSON(details.formName)
                            cleanPrivateValidations(schema) // This would be removed in future, but currently there is no server API to clean the files
                            resolve(schema)

                        } else {
                            console.error("Unknown form type was provided: " + details.formType)
                        }
                    });
                }]);
            })
        }


        function getVariables(varNames) {
            return new Promise(resolve => {
                if (camForm.taskId != null) {
                    inject(['$http', 'Uri', function ($http, Uri) {
                        let taskId = camForm.taskId;

                        let variables = {}
                        let promises = []

                        _.forEach(varNames, function (varName) {
                            if (!variables.hasOwnProperty(varName)) {
                                let promise = $http.get(Uri.appUri('engine://engine/:engine/task/' + taskId + '/variables/' + varName), {params: {deserializeValue: false}})
                                promises.push(promise)
                                promise.then(response => {

                                    if (response.data.type === 'Json') {
                                        response.data.value = JSON.parse(response.data.value)
                                    }
                                    variables[varName] = response.data.value
                                })
                            }

                        })
                        Promise.all(promises).then(function () {
                            resolve(variables)
                        })
                    }])
                } else {
                    resolve({})
                }

            })
        }

        function getDefaultValues(variablesStore, submissionObject, schema){
            let defaultValues = {data: {}}
            FormioUtils.eachComponent(schema.components, component => {
                if (component.hasOwnProperty("properties")){
                    if (component.properties.hasOwnProperty(camVariableNameKey)) {
                        let defaultValue = _.get(variablesStore, component.properties[camVariableNameKey])
                        let key = component.key

                        if (component.properties[stringifyKey] === "true"){
                            // @TODO do a check if the value is a object!
                            defaultValue = JSON.stringify(defaultValue)
                        }

                        defaultValues.data[key] = defaultValue
                    }
                }
            })
            return defaultValues
        }

        function isJsonString(str) {
            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            return true;
        }

        function setupSubmissionVariables(submission) {
            let customSubmissionVariableName = getParameterByName(submissionVariableNameParam, camForm.options.formUrl);
            let transientVariableParamValue = getParameterByName(submitAsTransientVariableParam, camForm.options.formUrl);

            var variableManager = camForm.variableManager;
            $scope.formioSubmission = submission
            let submissionVariable = {
                name: (camForm.taskId != null) ? camForm.taskId + submissionSuffix : startFormVariableName,
                type: 'Json',
                value: submission,
                valueInfo: {transient: submitAsTransientVariableDefault},
                isDirty: true
            }

            if (customSubmissionVariableName != null) {
                submissionVariable.name = customSubmissionVariableName
            }

            if (transientVariableParamValue != null) {
                if (transientVariableParamValue === 'true') {
                    submissionVariable.valueInfo = {transient: true}
                }
            }

            variableManager.createVariable(submissionVariable);
        }


        camForm.on('form-loaded', function () {
            $scope.options.hideCompleteButton = true
            getSchema().then(schema => {
                let varNames = []
                FormioUtils.eachComponent(schema.components, component => {
                    if (_.has(component.properties, fetchVariableKey)){
                        varNames.push(component.properties[fetchVariableKey])
                    }
                })

                return {schema: schema, varNames: varNames}

            }).then(details => {
                return getVariables(details.varNames).then(variables => {
                    //TODO should variables be stored in camForm or just the scope?
                    // This is done so we can access the variables from formio for default value population
                    $scope.camForm.formioVariables = variables
                    return details
                })

            }).then(details => {
                // TODO add a loading text
                try {
                    Formio.createForm(document.getElementById(formioDivId), details.schema)
                        .then(function (form) {
                            $scope.formioForm = form
                            form.nosubmit = true;

                            form.submission = getDefaultValues($scope.camForm.formioVariables, form.submission.data, form.schema)

                            camForm.on('submit-failed', function (evt, res) {
                                console.log("Camunda-Formio Submission Validation Error")
                                let error = res[0].message

                                let formioError = (function() {
                                    let content = error.slice(error.indexOf(': ') + 1)
                                    if (isJsonString(error)){
                                        return {validationError: true, error: JSON.stringify(content) }
                                    } else {
                                        return {validationError: false, error: content}
                                    }
                                })()

                                if (formioError.validationError){
                                    $scope.formioForm.showErrors(formioError.error.details)
                                } else {
                                    $scope.formioForm.showErrors([formioError.error])
                                }

                                $scope.formioForm.emit('submitError')
                            });

                            camForm.on('submit-success', function (evt) {
                                $scope.formioForm.emit('submitDone', $scope.formioSubmission)
                                // $scope.formioSubmitPromise.resolve()
                            })

                            form.on('submit', submission => {
                                setupSubmissionVariables(submission)

                                if (submission['@bpmn-escalation'] === true && submission['@bpmn-error'] === true) {
                                    throw "cannot have a bpmn-escalation & a bpmn-error at the same time."
                                    //https://docs.camunda.org/manual/7.12/reference/embedded-forms/controls/bpmn-buttons/
                                } else if (submission['@bpmn-error'] === true) {

                                } else if (submission['@bpmn-escalation'] === true) {

                                } else {
                                    $scope.complete()
                                }

                            })

                        });
                } catch (e) {
                    log.error(e)
                }
            })
        });
    </script>
</form>